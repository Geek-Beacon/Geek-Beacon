<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Geek Beacon Documentation Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Geek Beacon Documentation Site Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Geek Beacon Documentation Site" href="/opensearch.xml"><title data-react-helmet="true">Docker Guide Part 1 | Geek Beacon Documentation Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://geekbeacon.github.io/blog/docker_guide"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="Docker Guide Part 1 | Geek Beacon Documentation Site"><meta data-react-helmet="true" name="description" content="Preamble"><meta data-react-helmet="true" property="og:description" content="Preamble"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2020-05-18T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/insanitywholesale"><meta data-react-helmet="true" property="article:tag" content="engineering,docker"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://geekbeacon.github.io/blog/docker_guide"><link data-react-helmet="true" rel="alternate" href="https://geekbeacon.github.io/blog/docker_guide" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://geekbeacon.github.io/blog/docker_guide" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.53f1ed65.css">
<link rel="preload" href="/assets/js/runtime~main.53e6e39b.js" as="script">
<link rel="preload" href="/assets/js/main.6af2c053.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="GB Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.png" alt="GB Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Geek Beacon Documentation</b></a><a class="navbar__item navbar__link" href="/docs/intro/welcome">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" postsperpage="3" blogsidebarcount="ALL" feedoptions="[object Object]" href="/blog">Blog</a><a class="navbar__item navbar__link" target="_self" href="/blog/tags/engineering">Tech Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/GeekBeacon/geekbeacon-docs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/blog/docker_guide">Docker Guide Part 1</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/welcome">Welcome</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">Docker Guide Part 1</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2020-05-18T00:00:00.000Z" itemprop="datePublished">May 18, 2020</time> Â· <!-- -->24 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><a href="https://github.com/insanitywholesale" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_o0gy" src="https://avatars3.githubusercontent.com/u/45580420?s=460&amp;u=292dddc5e11159cd72839eb622f785db3952edaf&amp;v=4" alt="lhz"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/insanitywholesale" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">lhz</span></a></div><small class="avatar__subtitle" itemprop="description">Docker Guide Part 1</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_mojV" id="preamble">Preamble<a class="hash-link" href="#preamble" title="Direct link to heading">â€‹</a></h2><p>Docker is quite popular and has a lot of benefits if used appropriately.
This tutorial will hopefully help readers become more familiar with it.
You snooze, you lose so let&#x27;s get into it.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="prerequisites">Prerequisites<a class="hash-link" href="#prerequisites" title="Direct link to heading">â€‹</a></h2><ul><li>MUST:<ul><li>Have Linux installed</li><li>Have docker installed</li><li>Internet connection to download images</li><li>Some Linux knowledge</li></ul></li><li>OPTIONAL:<ul><li>Dockerhub account to push images to</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="concepts-and-architecture">Concepts and Architecture<a class="hash-link" href="#concepts-and-architecture" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="images-and-containers">Images and Containers<a class="hash-link" href="#images-and-containers" title="Direct link to heading">â€‹</a></h3><p>What are images, what are containers and how are they different?
Images are a snapshot of a system while containers are a running instance of an image.
For example, the nginx docker image has all the necessary bits installed to run nginx.
When we start that image, there is now an nginx container running.</p><p>To see it action, we can run<br>
<code>docker image ls</code><br>
<!-- -->to see all docker images on our system.
To download a new one, also referred to as pulling an image, we can run
<code>docker pull nginx</code><br>
<!-- -->or if a specific version is required,<br>
<code>docker pull nginx:1.17.10</code></p><p>Images are also immutable meaning they don&#x27;t keep any changes you make to them.
If we were to go into an ubuntu container, run <code>apt update &amp;&amp; apt -y full-upgrade</code> then restart the container, the updates would be lost.
To demonstrate it, we can run<br>
<code>docker run --rm -i -t ubuntu</code><br>
<!-- -->then when we see the shell prompt change, run<br>
<code>touch testfile &amp;&amp; ls</code><br>
<!-- -->followed up by <code>exit</code>.
Running<br>
<code>docker run --rm -i -t ubuntu</code><br>
<!-- -->again followed up by <code>ls</code> shows that the file named <code>testfile</code> does not exist there anymore.
The interactive shell won&#x27;t really come up again until we get to debugging. Unlike virtual machines, containers are not meant to be used interactively.</p><ul><li>Some notes so far:<ul><li>The <code>--rm</code> removes the container when the docker command exits (not necessary here but good for testing so we don&#x27;t fill up our system with unneeded containers)</li><li>The <code>-i -t</code> gives us an interactive terminal to execute commands in this case (this is not available on every image, for example postgres and nginx show logs<ul><li>In the case of nginx and postgres, even without (<code>-it</code>) they capture the terminal with logging so we use <code>-d</code> to run them in detached mode</li><li>The <code>--name</code> option gives a (hopefully) human-readable name to the container, especially useful when used with <code>-d</code></li></ul></li><li>docker pulls the image we specified (in this case the ubuntu one) if it&#x27;s not on the system yet when we use <code>docker run</code></li><li>There is a special image named <code>scratch</code> if you want to build things from the lowest level allowable</li></ul></li></ul><p>Containers can be started and stopped but it&#x27;s more complex than that as is evident from our experimentation and notes this far.
We&#x27;ll return to using nginx now since most images are going to be centered around the included application.
Using<br>
<code>docker run -d --name ngx-alp nginx:alpine</code><br>
<!-- -->we start an alpine-based nginx container running in detached mode.<br>
<!-- -->After checking the output of<br>
<code>docker container ls</code><br>
<!-- -->specifically the NAMES column, we can see that it did indeed start and was assigned the desired name.
A quick<br>
<code>docker stop ngx-alp</code><br>
<!-- -->will make it disappear from <code>docker container ls</code> but not from everywhere.
If we try to run<br>
<code>docker run -d --name ngx-alp nginx:alpine</code><br>
<!-- -->then docker will return an error since there is a container with that name but in stopped state.
We can confirm that using<br>
<code>docker container ls --all</code><br>
<!-- -->and then choose to start it again using<br>
<code>docker start ngx-alp</code><br>
<!-- -->or remove it using<br>
<code>docker rm ngx-alp</code><br>
<!-- -->Remember, we didn&#x27;t use <code>--rm</code> so the container did not get automatically removed after we stopped it.
You might have figured it out already but the containers are given random unique names as well as a unique ID, both of which can be used to address them when we want to stop, start or remove them.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="tags">Tags<a class="hash-link" href="#tags" title="Direct link to heading">â€‹</a></h3><p>What is the <code>:1.17.10</code> I added to the pull command in the previous section?
Clearly it&#x27;s a version number but more importantly it&#x27;s an image tag.
Tags allow us to specify the flavour or edition of the image that we want to use.
For example, to pull an alpine-based nginx image, we can run
<code>docker pull nginx:1.17.10</code><br>
<!-- -->or
<code>docker pull nginx:1.17.10-alpine</code><br>
<!-- -->to be more explicit.
If none is specified, the <code>:latest</code> tag is used so it is the default tag, keep this in mind.
Images can have multiple tags so <code>nginx:latest</code> and <code>nginx:1.17.10</code>(at the time of writing) will pull the same image but that won&#x27;t be true forever.
Explicitly specifying tags is useful to avoid the &quot;works on my machine&quot; type of issues when working with docker.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="ports">Ports<a class="hash-link" href="#ports" title="Direct link to heading">â€‹</a></h3><p>Many applications communicate over ports so how do we deal with that communication and move further along with our nginx example.
The port required for a basic &quot;this works&quot; page to load from nginx is 80. However, if you were to run <code>docker run nginx</code> and try to
<code>curl http://localhost:80</code><br>
<!-- -->it would not work.
For an analogy with more conventional setups, think of it as port forwarding being required.
Port 80 inside the container needs to be mapped to a port on the system in order to become accessible which is controlled by the <code>-p</code> option.
I will use distinct ports to make the example more clear so here we go, run
<code>docker run -d -p --name ngx 3000:80 nginx</code><br>
<!-- -->(which will use `<code>nginx:latest</code>) and then run<br>
<code>curl http://localhost:3000</code><br>
<!-- -->This should return a bit of HTML and internal CSS to indicate that the default nginx page is reachable.
We see that port 3000 outside of the container is mapped to port 80 inside of the container.
To make sure, we can try
<code>docker run -d -p --name ngx2 4000:80 nginx</code><br>
<!-- -->and then
<code>curl http://localhost:4000</code><br>
<!-- -->to see that it works and try
<code>docker run -d -p --name ngx2 3000:80 nginx</code><br>
<!-- -->to check that it won&#x27;t allow us to start it since port 3000 is already used by another container.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="networking">Networking<a class="hash-link" href="#networking" title="Direct link to heading">â€‹</a></h3><p>From the get-go, docker has a bridge network that all containers connect to by default but don&#x27;t have the perks of name resolution like user-defined bridge networks do.
What is a bridge network though and are there other types of networks?<br>
<!-- -->We&#x27;ll go through them one by one and explain what they&#x27;re useful for.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="bridge">Bridge<a class="hash-link" href="#bridge" title="Direct link to heading">â€‹</a></h4><p>First, bridge networks. By utilizing NAT, in a similar way that a router does, they are able to have containers communicate over them (or not for security reasons). Each container connected to a bridge network gets its own IP address and there are iptables rules added to block or allow traffic between networks and containers (or ports as we saw in the previous section). While the default bridge network that docker creates is mostly fine for testing and messing around, user-defined networks have a few advantages that make them suitable for more proper use such as:  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">- DNS resolution to make containers able to communicate using names and not IPs which could change</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">- Isolation since a container has to be explicitly added to them</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">- Adding and removing a container can be done on the fly (without starting and stopping)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">- Configurability such as using a larger MTU and in general tweaking them for the use case</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">- Sharing environment variables</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">- Have effectively all ports exposed between them</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">- Not having to use the deprecated `--link` flag  </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>So it&#x27;s safe to say that using user-defined ones is worth it. How to go about it then?
Time to find out.<br>
<!-- -->In order to create a network we just have to run
<code>docker network create bridge-net</code>
or<br>
<code>docker network create --driver bridge bridge-net</code><br>
<!-- -->and to delete it we use<br>
<code>docker network rm bridge-net</code><br>
<!-- -->but how do we use it?<br>
<!-- -->For this, we&#x27;ll need two containers. Let&#x27;s pick alpine since it includes the <code>ping</code> command. The flag to specify what network to attach the container to is <code>--network</code> so the full commands are as follows</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker run -dit --name alpine1 --network bridge-net alpine:latest</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker run -dit --name alpine2 --network bridge-net alpine:latest</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The above will run two containers in detached mode and enable the interactive terminal. We can connect to that terminal,<br>
<code>docker attach alpine1</code><br>
<!-- -->after which we get a prompt inside it.
Let&#x27;s test out that name resolution by pinging it 3 times<br>
<code>ping -c 3 alpine2</code><br>
<!-- -->which should work wonderfully. This means our containers can talk to eachother using their names while also having randomly assigned addresses from docker&#x27;s subnet.
In case we forget the network&#x27;s details, it is possible to use
<code>docker network list</code><br>
<!-- -->to find the network&#x27;s name followed by
<code>docker inspect bridge-net</code>
and get the network&#x27;s details in JSON format.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="macvlan">Macvlan<a class="hash-link" href="#macvlan" title="Direct link to heading">â€‹</a></h4><p>When integration with the network that the host is connected to is desired, we can use macvlan. Despite VLAN being a part of the name, using them is an option rather than a requirement. Let&#x27;s start with the possibly more familiar mode.  </p><h5 class="anchor anchorWithStickyNavbar_mojV" id="bridge-mode">Bridge mode<a class="hash-link" href="#bridge-mode" title="Direct link to heading">â€‹</a></h5><p>In this mode, the network is bridged to a physical interface on the host and it integrates with the underlying network.</p><p>To see it in action, (I&#x27;ll assume a fairly standard home network scheme) we can look at</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ ip r</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">default via 192.168.1.1 dev eth0 metric 2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">172.16.0.0/16 dev virbr0 proto kernel scope link src 172.16.0.1 linkdown</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">172.18.0.0/16 dev br-b0ed5d210b62 proto kernel scope link src 172.18.0.1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>to find our interface&#x27;s name, <code>eth0</code> in this case and then create the network
<code>docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 macvlan-net</code><br>
<!-- -->Connecting containers to it is done the same way we previously used. For example,
<code>docker run -dit --name alpine-on-macvlan --network macvlan-net alpine:latest</code></p><h5 class="anchor anchorWithStickyNavbar_mojV" id="8021q-mode">802.1q mode<a class="hash-link" href="#8021q-mode" title="Direct link to heading">â€‹</a></h5><p>I&#x27;m not going to go too in-depth about this mode since the amount of people with level 2 or level 3 managed switches is limited but it deserves at least a brief mention. If you&#x27;ve worked with VLANS on linux, you know that new interfaces are created, usually in the format the name of the physical parent followed by a dot <code>.</code> and then the VLAN number. To create a network linked to VLAN 31 on the <code>eth0</code> interface, we use the same command as before but with a VLAN interface instead like so
<code>docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0.31 macvlan31-net</code></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="storage">Storage<a class="hash-link" href="#storage" title="Direct link to heading">â€‹</a></h3><p>So far we have not looked into how we work with storing data.<br>
<!-- -->In the beginning it was stated and demonstrated that any changes made do not persist.
How do people use containers to run file servers and databases then?
The answer is bind mounts and volumes.
Bind mounts map a specified directory on the host to one inside the container.
Volumes on the other hand are managed through docker and are a bit more isolated from the host&#x27;s functionality.
Every time we ran a container, an anonymous volume was created.
Instead, we could have created a named volume using
<code>docker volume create ngx-vol</code><br>
<code>docker run --name ngx-with-vol -p 3000:80 --mount source=ngx-vol,target=/usr/share/nginx/html nginx</code><br>
<!-- -->The volumes are under <code>/var/lib/docker/volumes</code> in case you were wondering.
Volumes can be shared between two containers and be mounted read-only but we won&#x27;t be going into that right now.
With bind mounts, it looks a bit different since we need to pick a directory on the host.
If the directory doesn&#x27;t exist it will be created for us by docker.
Let&#x27;s try it using<br>
<code>docker run --name ngx-with-bind-mount -p 3000:80 -v /tmp/ngx:/usr/share/nginx/html nginx</code><br>
<!-- -->which will mount /tmp/ngx from the host to /usr/share/nginx/html in the container.
This gives us an error if we try to
<code>curl http://localhost:3000</code><br>
<!-- -->because the bind mounted host directory doesn&#x27;t get filled with the contents of the container&#x27;s target directory.
There is an alternative syntax for this using the <code>--mount</code> option which is as follows<br>
<code>docker run -d --rm --name ngx-w-alt-bind-mount -p 3000:80 --mount type=bind,source=/tmp/nginx,target=/usr/share/nginx/html nginx</code><br>
<!-- -->and will not create the directory on the host if it doesn&#x27;t exist.
That&#x27;s the main gist about storage when it comes to docker. The thing most often found in the wild is bind mounts with the <code>-v</code> syntax and named volumes.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="installing">Installing<a class="hash-link" href="#installing" title="Direct link to heading">â€‹</a></h4><p>There are multiple ways to install docker-compose. From your distributions repositories, from third-party repositories, from the realease binary, from source, from pip but by far my favorite is as a docker container. Take a look <a href="https://docs.docker.com/compose/install/#install-as-a-container" target="_blank" rel="noopener noreferrer">over here</a> if you&#x27;re interested, otherwise choose the way you prefer to get it installed to your system. After that, we&#x27;re ready to write some YAML.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="usage">Usage<a class="hash-link" href="#usage" title="Direct link to heading">â€‹</a></h4><p>Taking advantage of docker-compose is mainly by writing a file that describes how you want your services set up. Just make sure to pay attention to indentation because YAML is very picky about that (be prepared to give the spacebar a proper workout). What images will we work with?</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="building-images">Building Images<a class="hash-link" href="#building-images" title="Direct link to heading">â€‹</a></h2><p>All the talk about using docker is good but with kubernetes dominating the industry as far as orchestration, docker finds its home as a way to build images and as a container runtime.
How do you build an image then? It all starts with a Dockerfile.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="dockerfile">Dockerfile<a class="hash-link" href="#dockerfile" title="Direct link to heading">â€‹</a></h3><p>Similar to a Makefile but used for docker containers instead, the Dockerfile describes how to build your image. The first statement is <code>FROM</code> which specifies which base image to use. Other things you need is at least a little bit of familiarity with the tooling used by the project so you can discern what errors mean. Don&#x27;t be intimidated by that though, we&#x27;ll be going through it step by step. </p><h4 class="anchor anchorWithStickyNavbar_mojV" id="single-stage-example-build">Single-stage example build<a class="hash-link" href="#single-stage-example-build" title="Direct link to heading">â€‹</a></h4><p>For our starting example, we&#x27;ll use nginx and the following simple index.html:  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;!DOCTYPE html&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;html&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;head&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        &lt;title&gt;First Docker Image&lt;/title&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;/head&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;body&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        &lt;h1&gt;It exists and it works.&lt;/h1&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;/body&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/html&gt;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>So we create a new file named Dockerfile and put the following in it  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM nginx:1.17.10-alpine</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We could bind-mount our files but shipping them inside the image is we&#x27;d need if this was a website we were packing so let&#x27;s do it. I&#x27;m making the assumption that index.html is in the current working directory</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM nginx:1.17.10-alpine</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY ./index.html /usr/share/nginx/html/</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Without a port exposed, it won&#x27;t be accessible even if we bind ports to it so let&#x27;s do that next</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM nginx:1.17.10-alpine</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY ./index.html /usr/share/nginx/html/</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EXPOSE 80</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The final thing we should put in there is what command will be ran when the container starts. Running as a daemon is not desired since it will be in the foreground so we turn that off.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM nginx:1.17.10-alpine</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY ./index.html /usr/share/nginx/html/</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EXPOSE 80</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now for building the image we can run a simple<br>
<code>docker build -f Dockerfile .</code><br>
<!-- -->to do the job. The <code>-f</code> specifies what file to use to build the image and <code>.</code> signifies the current working directory as the build context.
We don&#x27;t necessarily have to specify the file every time, if it is named <code>Dockerfile</code> it will be used automatically.  </p><p>That&#x27;s not fancy enough though. We should probably give it a name and a tag (otherwise it will be tagged with <code>:latest</code>)
<code>docker build -t first-site:0.0.1 .</code><br>
<!-- -->Running the old faithful<br>
<code>docker image ls</code><br>
<!-- -->should reflect that our custom image was built and tagged appropriately.  </p><p>Congratulations, you just built your first docker image. But things are never this simple, right? We&#x27;re not always going to be working with websites let alone ones that have less than 10 lines of HTML. Let&#x27;s try something a bit more realistic. What about...a microservice written in golang exposing an api centered around a list of coffees?</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="multi-stage-golang-example-build">Multi-stage golang example build<a class="hash-link" href="#multi-stage-golang-example-build" title="Direct link to heading">â€‹</a></h4><p>I am going to be using <a href="https://github.com/insanitywholesale/microsrv" target="_blank" rel="noopener noreferrer">this</a> for demonstration. Ignore the included dockerfile, our main focus now is to understand the steps required to make images. After cloning the project and entering its directory, delete the included Dockerfile (it&#x27;s not as correct as the one we&#x27;re going to make anyway) and make an empty one. Just the same as before, we&#x27;re going to start with a <code>FROM </code> statement.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Picking version 1.14.2 since that is the latest at the time of writing and the code has been tested to work with it.
Next, we&#x27;re going to go into the <code>$GOPATH</code> directory, in a subdirectory named <code>src</code> and then in a subdirectory with our project&#x27;s name. Note that we use <code>/go/src/microsrv</code> since <code>$GOPATH</code> is resolved to <code>/go</code> in this image.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We could have used the <code>RUN</code> statement and done <code>RUN cd $GOPATH/src/microsrv</code> but the <code>WORKDIR</code> command works at the Dockerfile level meaning that all subsequent commands will use it and it also creates the directory in case it doesn&#x27;t exist already.
After that, it&#x27;s time to copy over the project files using <code>COPY</code></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>this copies the contents of our current working directory outside of the container (project&#x27;s root) into the current working directory inside the container ($GOPATH/src/microsrv)
Following that, we run the command to download all the required dependencies and source code but not build or install the project (that&#x27;s due to using <code>-d</code>). Here the <code>RUN</code>statement is used which executes the command after it inside the container.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Of course in the end we want to build and install the project so let&#x27;s do that</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Right after that is exposing the port, 9090 in this case</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EXPOSE 9090</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The last piece missing is the command to be executed</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EXPOSE 9090</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CMD [&quot;microsrv&quot;]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>On to building the image now<br>
<code>docker build -t coffee-api:0.0.1 .</code>
and then running and testing it
<code>docker run --rm -d --name coffee-api -p 9090:9090 coffee-api:0.0.1</code>
<code>curl http://localhost:9090/products</code><br>
<!-- -->which should return a JSON-formatted object of all the coffees and their public-facing details.
This is all fine and dandy but if we check <code>docker image ls</code> we see that the resulting image is about 1GB in size which just won&#x27;t fly. We have to optimize but how? One way is to think of what&#x27;s needed in compile-time compared to run-time. The entire language is not required after the project has been built and not much if any operating-system level tools are required other than for debugging.  </p><p>To achive this separation we can use multi-stage builds.
The first step is taking out runtime-specific things out of the build stage.
What port gets exposed and what command is ran when the container starts is not in the build stage&#x27;s scope so let&#x27;s remove those.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Time to build the second stage. First we&#x27;ll use an alias for the first stage in order to be able to copy stuff from it.  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>With that done, let&#x27;s define the second stage inside the same file. We&#x27;ll use busybox, a very small image that has just enough to be usable for our case. Since the default image uses glibc as its C library, we&#x27;ll specify that tag since busybox doesn&#x27;t use it by default.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM busybox:glibc</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here is where the alias comes in handy when copying the resulting binary (located at $GOPATH/bin/microsrv) from the first stage</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM busybox:glibc</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY --from=build /go/bin/microsrv /</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>And finally we add the two lines that were removed  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM golang:1.14.2 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /go/src/microsrv</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go get -d -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN go install -v ./...</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM busybox:glibc</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY --from=build /go/bin/microsrv /</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EXPOSE 9090</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CMD [&quot;/microsrv&quot;]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>All that&#x27;s left now is to build (I incremented the version number so the image doesn&#x27;t steal the previous one&#x27;s tagged name but normally you want the docker image version to match the version of the application)
<code>docker build -t coffee-api:0.0.2 .</code>
then run and test<br>
<code>docker run --rm -d --name coffee-api -p 9090:9090 coffee-api:0.0.1</code>
<code>curl http://localhost:9090/products</code>  </p><p>If everything went according to plan, a JSON object with the coffees was returned to you and you&#x27;ve built your first multi-stage docker image (which you should remember to stop using <code>docker stop coffee-api</code>). We&#x27;re not done yet though, maybe it&#x27;s time we throw our old pal nginx back into the mix and move from the backend to the frontend.</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="multi-stage-reactjs-example-build">Multi-stage reactjs example build<a class="hash-link" href="#multi-stage-reactjs-example-build" title="Direct link to heading">â€‹</a></h4><p>Now that our backend is all packed up, time to see how we&#x27;d go about doing the same thing with the frontend. This time we have to interact with nodejs during the build but it&#x27;s not required for runtime. I think you get an idea of what&#x27;s to come so let&#x27;s not hesitate.</p><p>The project I&#x27;ll be using for this demonstration is <a href="https://gitlab.com/insanitywholesale/reactionary" target="_blank" rel="noopener noreferrer">this</a>, just a simple one-page counter application. Same as the previous example, we&#x27;ll clone it, change into its directory and delete the included Dockerfile since we&#x27;ll be remaking it from scratch.
As I mentioned, it&#x27;s good to know the project&#x27;s tooling, in this case we need node and npm for building the application but not for running it. We&#x27;ll start with a <code>FROM</code> statement to grab the node image but pre-emptively optimize by going with the alpine flavour. The size comparison between the regular version is as follows and should explain why this is a better choice.  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ docker images | grep node</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">node                             alpine              0854fcfc1637        2 days ago          117MB</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">node                             latest              a511eb5c14ec        2 days ago          941MB</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Coming in at over 8 times the size of the alpine one, the main image is massive and doesn&#x27;t include anything we need and won&#x27;t get otherwise.
Starting with our Dockerfile then, we pick the latest (at the time of writing) node image based on the latest alpine version and alias it to <code>build</code> since it will be our build stage</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM node:14.1.0-alpine3.11 as build</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We then change our current working directory to <code>/app</code> and move all of our project&#x27;s freshly cloned files in there</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM node:14.1.0-alpine3.11 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /app</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now on to getting everything installed and ready for the build. Since it&#x27;s a reactjs website and the scripts that will be run (as defined in package.json) are from the <code>react-scripts</code> package (which needs to be installed globally) we will opt for installing that first before the usual <code>npm install</code>. Here is the Dockerfile up until now  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM node:14.1.0-alpine3.11 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /app</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm install --global react-scripts</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm install</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To finish up the build stage one last command is required in order to generate the files that nginx will serve  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM node:14.1.0-alpine3.11 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /app</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm install --global react-scripts</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm install</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm run build</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>There we go then. The resulting files will be inside the container in the <code>/app/build</code> directory. No instructions for exposing any ports or the starting command we specified since that&#x27;s for the runtime stage. Speaking of which, you might have already guessed what the rest of the Dockerfile will look like. Start with an nginx alpine image, copy over only the necessary files to it from the build stage, open up port 80 and start nginx in foreground mode. Here is the final result</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM node:14.1.0-alpine3.11 as build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">WORKDIR /app</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY . .</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm install --global react-scripts</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm install</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">RUN npm run build</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">FROM nginx:1.17.10-alpine</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">COPY --from=build /app/build /usr/share/nginx/html</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EXPOSE 80</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>After we&#x27;re done with that, we should actually build the image and give it a descriptive tag<br>
<code>docker build -t reactjs-counters:0.0.1 .</code><br>
<!-- -->followed up by starting it in order to test
<code>docker run --rm -d --name reactjs-counters -p 80:80 reactjs-counters:0.0.1</code>
and then visit<br>
<code>http://localhost</code><br>
<!-- -->in your browser of choice to see if it works.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="publishing-images">Publishing Images<a class="hash-link" href="#publishing-images" title="Direct link to heading">â€‹</a></h2><p>We&#x27;ve made our image and sharing is caring so how do we make it available to the world and where are images stored? The go-to place for getting images is dockerhub, a public docker registry. Docker registries are where images are stored and distributed from. You can also run your own if you wish but that&#x27;s for another time. Right now, we have two images built and ready to be shipped. Well...almost. We could certainly upload them as they are and then try to pull them but we&#x27;d find that we need to specify a tag. That happens because they&#x27;re not tagged as <code>:latest</code> which is the default tag. One step at a time though.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="dockerhub">DockerHub<a class="hash-link" href="#dockerhub" title="Direct link to heading">â€‹</a></h3><p>First, you should make an account if you don&#x27;t have one already by going over on the <a href="https://hub.docker.com/signup" target="_blank" rel="noopener noreferrer">dockerhub website</a> and signing up. Next up, run <code>docker login</code> in a terminal to, you guessed it, log in. This will allow you to push images to your account. I already got mine so we&#x27;re ready to start.  </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="tagging">Tagging<a class="hash-link" href="#tagging" title="Direct link to heading">â€‹</a></h3><p>Since we just finished making our reactjs-based image, let&#x27;s use it here too. Previously we only tagged it as <code>reactjs-counters:0.0.1</code> but we need something more now. The format of the image name should be <code>username/image:tag</code>. There at least 2 ways to go about this. Either rebuild the image and tag it differently or tag the existing one. I&#x27;ll go over both of them.</p><p>First, let&#x27;s look at the &quot;I wish I&#x27;d known sooner&quot; method. As we know, images have a unique identifier. This is under the `<code>IMAGE ID</code> column in <code>docker image ls</code> output. A single image can be tagged with different names. So here is the way we&#x27;d build it with multiple tags, one of them being the properly versioned one and the other one being latest (don&#x27;t forget to substitute <code>username</code> with your actual username):<br>
<code>docker build -t username/reactjs-counters:0.0.1 -t username/reactjs-counters:latest .</code><br>
<!-- -->And there we have it. Simple enough, ain&#x27;t it? But how about tagging an already existing image? Someone might not fancy rebuilding theirs.</p><p>That&#x27;s what the <code>docker tag</code> command is for. All we have to do is find the image ID from the output of <code>docker image ls</code> and then tag it twice. Here we go then (assuming this is the image ID <code>7755c1923b8a</code>):</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker tag 7755c1923b8a username/reactjs-counters:0.0.1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker tag 7755c1923b8a username/reactjs-counters:latest</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="pushing">Pushing<a class="hash-link" href="#pushing" title="Direct link to heading">â€‹</a></h3><p>All that&#x27;s left is to <code>docker push</code> the image of our choice and make it available so other people can <code>docker pull</code> it.  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker push username/reactjs-counters:0.0.1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker push username/reactjs-counters:latest</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>And that&#x27;s it!<br>
<!-- -->We have successfully taken an application, written a Dockerfile for it, built an image for it and published it to DockerHub!</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="outro">Outro<a class="hash-link" href="#outro" title="Direct link to heading">â€‹</a></h2><p>Hopefully you&#x27;ve learned something useful about docker after reading this, I had fun writing it and looking into things that had faded from my memory. Docker is an interesting technology that can be leveraged in many ways to improve development and production workflows everywhere from a single board computer to a fleet of servers in a datacenter. Let me know what you thought about it and I hope you have a good rest of your day.</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/engineering">engineering</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/docker">docker</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/welcome"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Welcome</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#preamble" class="table-of-contents__link toc-highlight">Preamble</a></li><li><a href="#prerequisites" class="table-of-contents__link toc-highlight">Prerequisites</a></li><li><a href="#concepts-and-architecture" class="table-of-contents__link toc-highlight">Concepts and Architecture</a><ul><li><a href="#images-and-containers" class="table-of-contents__link toc-highlight">Images and Containers</a></li><li><a href="#tags" class="table-of-contents__link toc-highlight">Tags</a></li><li><a href="#ports" class="table-of-contents__link toc-highlight">Ports</a></li><li><a href="#networking" class="table-of-contents__link toc-highlight">Networking</a></li><li><a href="#storage" class="table-of-contents__link toc-highlight">Storage</a></li></ul></li><li><a href="#building-images" class="table-of-contents__link toc-highlight">Building Images</a><ul><li><a href="#dockerfile" class="table-of-contents__link toc-highlight">Dockerfile</a></li></ul></li><li><a href="#publishing-images" class="table-of-contents__link toc-highlight">Publishing Images</a><ul><li><a href="#dockerhub" class="table-of-contents__link toc-highlight">DockerHub</a></li><li><a href="#tagging" class="table-of-contents__link toc-highlight">Tagging</a></li><li><a href="#pushing" class="table-of-contents__link toc-highlight">Pushing</a></li></ul></li><li><a href="#outro" class="table-of-contents__link toc-highlight">Outro</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Social</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">MeetingNotes</a></li><li class="footer__item"><a href="https://github.com/Geek-Beacon/geekbeacon" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/geekbeacon" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.53e6e39b.js"></script>
<script src="/assets/js/main.6af2c053.js"></script>
</body>
</html>